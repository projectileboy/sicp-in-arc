;; SICP - Chapter 1 - Section 1.2


; "The ability to visualize the consequences of the actions under consideration is crucial
;   to becoming an expert programmer, just as it is in any synthetic, creative activity."
;
; Iterative processes can be faster and consume less memory than recursive processes,
;   but recursive processes can sometimes communicate an algorithm more clearly.
;
; Main topics:
; * Understanding the behavior of recursive and iterative processes
; * Order of growth
; * Understanding order of growth for various examples (Fibonacci, Fermat's primality test, etc.)
; *


; Exercise 1.9
; Illustrate the processes generated by each of these procedures in evaluating (+ 4 5)
;
(def + (a b)
   (if (is a 0) b
       (inc (+ (dec a) b))))
; (+ 4 5)
; (inc (+ 3 5))
; (inc (inc (+ 2 5)))
; (inc (inc (inc (+ 1 5))))
; (inc (inc (inc (inc (+ 0 5)))))
; (inc (inc (inc (inc 5))))
; (inc (inc (inc 6)))
; (inc (inc 7))
; (inc 8)
; 9

(def + (a b)
   (if (is a 0) b
       (+ (dec a) (inc b))))
; (+ 4 5)
; (+ 3 6)
; (+ 2 7)
; (+ 1 8)
; (+ 0 9)
; 9


; Exercise 1.10
; Ackermann's function:
(def A (x y)
    (if (is y 0) 0
        (is x 0) (* 2 y)
        (is y 1) 2
        (A (- x 1)
           (A x (- y 1)))))
(A 1 10)
; 1024
(A 2 4)
; 65536
(A 3 3)
; 65536

; 2n
(def f (n) (A 0 n))

; 2^n
(def g (n) (A 1 n))

;(A 2 n)
;(A 1 (A 2 (- n 1)))
;(A 0 (A 1 (- (A 2 (- n 1)) 1)))
;(* 2 (A 0 (A 1 (- (A 2 (- n 1)) 2))))
;(* 2 (* 2 (A 0 (A 1 (- (A 2 (- n 1)) 3)))))

;...and so on...

(def h (n) (A 2 n))

; 5n^2
(def k (n) (* 5 n n))





; Exercise 1.11

; Write an iterative function and a recursive function that computes
;  f(n) = n for n < 3; f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) for n >= 3.

(def recursive-f (n)
  (if (< n 3) n
      (+ (recursive-f (- n 1))
         (* 2 (recursive-f (- n 2)))
         (* 3 (recursive-f (- n 3))))))

; f(0) = 0
; f(1) = 1
; f(2) = 2

(def iterative-f (n)
  (def iter (a b c n)
    (if (is n 0) c
        (iter (+ a (* 2 b) (* 3 c)) a b (- n 1))))
  (iter 2 1 0 n))





; Exercise 1.12«                «

; A recursive procedure that will give us any given entry in Pascal's triangle
(def pascal (depth n)
  (if (or (> n depth) (< n 1)) 0
      (is 1 n) 1
      (is n depth) 1
      (+ (pascal (- depth 1) n)
                 (pascal (- depth 1) (- n 1)))))




; Exercise 1.13
; Exercise 1.14
; Exercise 1.15




; Exercise 1.16
(def even? (x) (is 0 (mod x 2)))

(def square (x) (* x x))

(def expt (x y)
    (if (is y 0) 1
        (even? y) (square (expt x (/ y 2)))
        (* x (expt x (- y 1)))))







; Exercise 1.17
; Exercise 1.18
; Exercise 1.19
; Exercise 1.20


; Exercise 1.21

; Use the 'smallest-divisor' procedure to find the smallest divisor of 199, 1999, 19999

(def find-divisor (n test-division)
    (if ))

(def smallest-divisor (n)
    (find-divisor n 2))



; Exercise 1.22
; Exercise 1.23
; Exercise 1.24
; Exercise 1.25
; Exercise 1.26
; Exercise 1.27
; Exercise 1.28





